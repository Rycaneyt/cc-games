-- pocket_send.lua  —  Sendet Datei/Ordner an einen PC-Receiver über rednet
-- Start: pocket_send <srcPath> [destSubdir] [receiverId]
-- Beispiele:
--   pocket_send meinScript.lua disk/
--   pocket_send games/ disk/games/ 17

-------------------------
-- Bit/Checksum Utils  --
-------------------------
local function bxor(a,b)
  if bit32 and bit32.bxor then return bit32.bxor(a,b) end
  if bit and bit.bxor then return bit.bxor(a,b) end
  error("Weder bit32 noch bit-Modul verfügbar")
end

local function lshift(a,n)
  if bit32 and bit32.lshift then return bit32.lshift(a,n) end
  if bit and bit.blshift then return bit.blshift(a,n) end
  error("Weder bit32 noch bit-Modul verfügbar")
end

local function adler32(str)
  local MOD = 65521
  local a,b = 1,0
  for i=1,#str do
    a = (a + string.byte(str, i)) % MOD
    b = (b + a) % MOD
  end
  return string.format("%08x", bxor(lshift(b, 16), a))
end

-------------------------
-- Helpers             --
-------------------------
local function findWirelessModem()
  if rednet.isOpen() then return true end
  if peripheral and peripheral.getNames then
    for _,name in ipairs(peripheral.getNames()) do
      if peripheral.getType(name) == "modem" then
        local m = peripheral.wrap(name)
        if m and m.isWireless and m.isWireless() then
          rednet.open(name)
          return true
        end
      end
    end
  end
  return false
end

local function isDir(path) return fs.exists(path) and fs.isDir(path) end
local function isFile(path) return fs.exists(path) and not fs.isDir(path) end

local function listRecursive(root)
  local files, dirs = {}, {}
  local function walk(p, rel)
    for _,name in ipairs(fs.list(p)) do
      local full = p .. "/" .. name
      local r = rel == "" and name or (rel.."/"..name)
      if fs.isDir(full) then
        table.insert(dirs, r)
        walk(full, r)
      else
        table.insert(files, r)
      end
    end
  end
  if fs.isDir(root) then
    table.insert(dirs, "") -- root selbst
    walk(root, "")
  end
  return files, dirs
end

local function readAll(path)
  local h=fs.open(path,"r"); local d=h.readAll() or ""; h.close(); return d
end

-------------------------
-- Args / Setup        --
-------------------------
local tArgs = {...}
local src      = tArgs[1]
local destSub  = tArgs[2] or ""
local receiverId = tonumber(tArgs[3] or "")

if not src or src == "" then
  print("Nutzung: pocket_send <srcPath> [destSubdir] [receiverId]"); return
end
if destSub ~= "" and destSub:sub(-1) ~= "/" then destSub = destSub.."/" end

if not findWirelessModem() then
  print("Kein Wireless-Modem gefunden/aktiv. Bitte Modem anbauen & aktivieren.")
  return
end

-- Receiver suchen, wenn keine ID übergeben
if not receiverId then
  local list = { rednet.lookup("ccxfer","RECEIVER") }
  if #list == 0 then
    print("Kein Receiver gefunden. Starte auf dem PC: pc_recv disk/"); return
  end
  receiverId = list[1]
end
print("Sende an Empfänger-ID:", receiverId)

-- Handshake
rednet.send(receiverId, {t="hello", version=1, wants="send"}, "ccxfer")
local rid, ack = rednet.receive("ccxfer", 4)
if rid ~= receiverId or type(ack) ~= "table" or not ack.ok then
  print("Receiver antwortet nicht/negativ."); return
end
local destRoot = ack.destRoot or "(remote)"

-------------------------
-- Transfer            --
-------------------------
local CHUNK = 8192

local function sendDir(relPath)
  rednet.send(receiverId, {t="dir_meta", relPath=destSub..relPath}, "ccxfer")
  local _, ack = rednet.receive("ccxfer", 6)
  return ack and ack.ok
end

local function sendFile(absPath, relPath)
  local data = readAll(absPath)
  local sum = adler32(data)
  local total = math.ceil(#data / CHUNK)
  rednet.send(receiverId, {t="file_meta", relPath=destSub..relPath, size=#data, checksum=sum}, "ccxfer")
  local _, mack = rednet.receive("ccxfer", 8)
  if not (mack and mack.ok and mack.t=="ack_file_meta") then
    print("Meta abgelehnt:", relPath); return false
  end

  local startIdx = (mack.resume and mack.resume ~= math.huge) and (mack.resume + 1) or 1
  if mack.resume == math.huge then
    print("  (übersprungen, bereits vorhanden)  "..relPath)
    return true
  end

  for idx=startIdx,total do
    local s = (idx-1)*CHUNK + 1
    local e = math.min(#data, idx*CHUNK)
    local chunk = data:sub(s,e)
    rednet.send(receiverId, {t="chunk", relPath=destSub..relPath, idx=idx, total=total, data=chunk}, "ccxfer")
    local _, ack = rednet.receive("ccxfer", 8)
    if not (ack and ack.ok and ack.idx == idx) then
      print("  Fehler/Timeout bei Chunk", idx, "-> retry")
      rednet.send(receiverId, {t="chunk", relPath=destSub..relPath, idx=idx, total=total, data=chunk}, "ccxfer")
      local _, ack2 = rednet.receive("ccxfer", 8)
      if not (ack2 and ack2.ok and ack2.idx == idx) then
        return false
      end
    end
    local pct = math.floor((idx/total)*100 + 0.5)
    print(string.format("  ▸ %s  [%d/%d] ~%d%%", relPath, idx, total, pct))
  end
  rednet.send(receiverId, {t="end_file", relPath=destSub..relPath}, "ccxfer")
  local _, eack = rednet.receive("ccxfer", 8)
  if not (eack and eack.ok) then
    print("Endbestätigung fehlgeschlagen:", relPath) ; return false
  end
  print("  ✔ gesendet:", relPath)
  return true
end

if isFile(src) then
  local rel = fs.getName(src)
  if not sendFile(src, rel) then print("Übertragung fehlgeschlagen.") return end
elseif isDir(src) then
  local files, dirs = listRecursive(src)
  for _,d in ipairs(dirs) do
    if d ~= "" then
      if not sendDir(d) then print("Warnung: Verzeichnis nicht bestätigt:", d) end
    end
  end
  for _,f in ipairs(files) do
    local abs = src.."/"..f
    if not sendFile(abs, f) then print("Abbruch bei Datei:", f) return end
  end
else
  print("Quelle nicht gefunden:", src) ; return
end

print("Fertig! Dateien liegen auf dem Empfänger unter:", destRoot..destSub)
